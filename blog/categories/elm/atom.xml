<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Elm | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/elm/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-23T13:03:22-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 1, Communicating With GitHub]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github/"/>
    <updated>2018-04-23T10:40:40-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github</id>
    <content type="html"><![CDATA[<p>A co-worker and are using GitHub&rsquo;s GraphQL API for a side project. I am writing a series of posts around what we learned from creating the application entitled &lsquo;GraghQL and Elm&rsquo;. This post will detail how to communicate with the Github GraphQL API with Elm. All code related to these posts can be found <a href="https://github.com/iacutone/github-elm">here</a>.</p>

<p>GitHub has extensive <a href="https://developer.github.com/v4/">documentation</a> on communicating with their GraphQL server. In this post we will write a simple query and display the JSON from Github. In the next post, we will use Elm Decoders in order to turn the JSON into Elm data.</p>

<p>The <a href="https://developer.github.com/v4/explorer/">GitHub GraphQL Explorer</a> is useful for crafting queries. Let&rsquo;s write a query that fetches a user&rsquo;s id:</p>

<pre><code class="json">{
  user(login:"iacutone") {
    id
  }
}
</code></pre>

<p>With the aforementioned JSON, let&rsquo;s contruct a request to GitHub in Elm!</p>

<pre><code class="haskell">query : String
query =
    """
    query {
        {
      user(login:"iacutone") {
        id
      }
    }
    }
    """

baseUrl : String
baseUrl =
    "https://api.github.com/graphql"

bearerToken : String
bearerToken =
    "Bearer &lt;your GitHub token here&gt;"

request : Http.Request String
request =
    Http.request
    { method = "POST"
    , headers = [Http.header "Authorization" bearerToken]
    , url = baseUrl
    , body = Http.jsonBody (Encode.object [("query", Encode.string query)])
    , expect = Http.expectString
    , timeout = Nothing
    , withCredentials = False
    }
</code></pre>

<p>After posting the query to GitHub, your Elm update function will receive the following response:</p>

<pre><code class="json">{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjE1NjMyMDE="
    }
  }
}
</code></pre>

<p>I find it helpful to define this response as an Elm <code>String</code> type and view it in the browser. If there is an error with the query, you can see the results in the browser.</p>

<pre><code class="haskell">-- MODEL

type alias Model =
    { response : String
    }

-- UPDATE

type Msg
    = GraphQLQuery (Result Http.Error String)

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            ( { model | response = res }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | response = toString res }, Cmd.none )

initialModel : Model
initialModel =
    { response = ""
    }

init : (Model, Cmd Msg)
init =
    ( initialModel, Http.send GraphQLQuery request )

main : Program Never Model Msg
main =
    Html.program
        { init = init 
        , view = view
        , update = update
        , subscriptions = \_ -&gt; Sub.none
        }

-- VIEW

view : Model -&gt; Html Msg
view model =
    div [] [ text model.response ]
</code></pre>

<p>The code above will display a stringfied version of our query. In Part 2, we will transform the Elm <code>String</code> data object into something more useful with Elm decoders.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Union Types in Elm]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/16/understanding-union-types-in-elm/"/>
    <updated>2018-04-16T18:19:13-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/16/understanding-union-types-in-elm</id>
    <content type="html"><![CDATA[<p>Watching <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Making Impossible States Impossible</a> and reading <a href="https://becoming-functional.com/higher-level-coding-with-elm-union-types-2502d1f5a615">Higher Level Coding with Elm Union Types</a> were enlightening in my Elm development. Now, I look for places were I can refine my data model by using union types. Union types allow me to replace conditionals with pattern matching case statements. This pattern is much cleaner and easier to understand. The following is an example of how I used union types to refactor a hamburger.</p>

<h2>Elm Model</h2>

<pre><code class="haskell">-- BEFORE

type Msg
    = DisplayHamburgerItems

type alias Model = 
    { hamburger_open : Bool
    }

-- AFTER

type Msg
    = DisplayHamburgerItems Hamburger

type Hamburger
    = Open
    | Closed


type alias Model = 
    { hamburger : Hamburger
    }
</code></pre>

<h2>Elm Update</h2>

<pre><code class="haskell">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =

    -- BEFORE

    case msg of
        DisplayHamburgerItems -&gt;
            if model.hamburger_open == True then
                let
                    items = List.append model.display_hamburger ["About", "Contact", "Menu"]
                in
                    ( { model | display_hamburger = items, hamburger_open = False }, Cmd.none )
            else
                ( { model | display_hamburger = [], hamburger_open = True }, Cmd.none 


    -- AFTER

        DisplayHamburgerItems msg -&gt;
            case msg of
                Open -&gt;
                    let
                        items = List.append model.display_hamburger ["About", "Contact", "Menu"]
                    in
                        ( { model | hamburger = Open, display_hamburger = items }, Cmd.none )
                Closed -&gt;
                    ( { model | hamburger =  Closed, display_hamburger = [] }, Cmd.none )
</code></pre>

<h2>Elm View</h2>

<pre><code class="haskell">view : Model -&gt; Html Msg
view model =

    -- BEFORE

    i [ onClick (DisplayHamburgerItems) ] []

    -- AFTER

    i [ onClick (DisplayHamburgerItems (toggleHamburger model.hamburger)) ] []

viewHamburgerItems : Model -&gt; Html Msg
viewHamburgerItems model =

    -- BEFORE

    if model.hamburger_open == False then
        div [] (List.map item model.display_hamburger)
    else
        div [] []

    -- AFTER

    case model.hamburger of
        Open -&gt;
            div [] (List.map item model.display_hamburger)
        Closed -&gt;
            div [] []
</code></pre>

<p>It is easier to reason about <code>Hamburger</code> with <code>Open</code> and <code>Closed</code> types than checking against a <code>Bool</code>. Pattern matching on the union type is expressive and is really helpful when the union types grow in complexity.</p>

<p>Full code <a href="https://github.com/iacutone/menus">here</a>.</p>
]]></content>
  </entry>
  
</feed>
