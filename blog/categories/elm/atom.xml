<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Elm | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/elm/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-26T17:05:37-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 2, Parsing Nested JSON]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/25/graphql-with-elm-part-2/"/>
    <updated>2018-04-25T14:17:04-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/25/graphql-with-elm-part-2</id>
    <content type="html"><![CDATA[<p>In this post we will discuss how to turn nested JSON into Elm data types. This post uses a thin <code>Elm.Http</code> <a href="https://github.com/NoRedInk/elm-decode-pipeline">wrapper</a>. Using this library helps us concentrate on contructing the necessary Decoders. We will also contruct a more complex query in order to explain how to contruct complex data types. The following query returns JSON for the first two team members of FracturedAtlas.</p>

<pre><code class="haskell">query : String
query =
    """
    query {
      organization(login: "FracturedAtlas") {
        team(slug: "fa-dev") {
          members(first:2) {
            edges {
              node {
                id
                login
              }
            }
          }
        }
      }
    }
    """
</code></pre>

<p>Swapping out our query will return the following JSON.</p>

<pre><code class="json">{"data":{"organization":{"team":{"members":{"edges":[{"node":{"id":"&lt;user id&gt;","login":"&lt;user name&gt;"}},{"node":{"id":"&lt;another user id&gt;","login":"&lt;user name&gt;"}}]}}}}}
</code></pre>

<p>The following part took me a long time to grok. The issues I had difficulty resolving are:
1. How do I grab the list of nodes?
1. How to I change my stringified JSON output into Elm data types?</p>

<p>The rest of this post tackles these two issues.</p>

<p>The <code>requiredAt</code> function from Elm Decode Pipeline solves the first problem.</p>

<pre><code class="haskell">decodeLogin =
    decode Users
            |&gt; requiredAt ["data", "organization", "team", "members", "edges"] (Json.Decode.list decodeNode)
        -- 'dig' into the JSON and extract the node list

decodeNode =
    decode Node
        |&gt; required "node" decodeUser

decodeUser =
    decode User
        |&gt; required "id" string
        |&gt; required "login" string
</code></pre>

<p>Let&rsquo;s construct our Elm datatypes based on the JSON response.</p>

<pre><code class="haskell">type alias Model =
    { message : String
    , users : Maybe Users
    }

type alias Users =
    { edges : List Node }

type alias Node =
    { node: User
    }

type alias User =
    { id:  String
    , login : String
    }
</code></pre>

<p>Now to handle the update function.</p>

<pre><code class="haskell">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            case decodeString decodeLogin res of
                Ok res -&gt;
                    ( { model | users = Just res }, Cmd.none )
                Err error -&gt;
                    ( { model | message = error, users = Nothing }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | users = Nothing }, Cmd.none )
</code></pre>

<p>I spent numerous hours figuring out how to map the Elm data types to the decoders. In Part 3, we will learn how to display the <code>User</code> data type in the browser.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 1, Communicating With GitHub]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github/"/>
    <updated>2018-04-23T10:40:40-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github</id>
    <content type="html"><![CDATA[<p>A co-worker and are using GitHub&rsquo;s GraphQL API for a side project. I am writing a series of posts around what we learned from creating the application entitled &lsquo;GraghQL and Elm&rsquo;. This post will detail how to communicate with the Github GraphQL API with Elm. All code related to these posts can be found <a href="https://github.com/iacutone/github-elm">here</a>.</p>

<p>GitHub has extensive <a href="https://developer.github.com/v4/">documentation</a> on communicating with their GraphQL server. In this post we will write a simple query and display the JSON from Github. In the next post, we will use Elm Decoders in order to turn the JSON into Elm data.</p>

<p>The <a href="https://developer.github.com/v4/explorer/">GitHub GraphQL Explorer</a> is useful for crafting queries. Let&rsquo;s write a query that fetches a user&rsquo;s id:</p>

<pre><code class="json">{
  user(login:"iacutone") {
    id
  }
}
</code></pre>

<p>With the aforementioned JSON, let&rsquo;s contruct a request to GitHub in Elm!</p>

<pre><code class="haskell">query : String
query =
    """
    query {
      {
        user(login:"iacutone") {
          id
        }
      }
    }
    """

baseUrl : String
baseUrl =
    "https://api.github.com/graphql"

bearerToken : String
bearerToken =
    "Bearer &lt;your GitHub token here&gt;"

request : Http.Request String
request =
    Http.request
    { method = "POST"
    , headers = [Http.header "Authorization" bearerToken]
    , url = baseUrl
    , body = Http.jsonBody (Encode.object [("query", Encode.string query)])
    , expect = Http.expectString
    , timeout = Nothing
    , withCredentials = False
    }
</code></pre>

<p>After posting the query to GitHub, your Elm update function will receive the following response:</p>

<pre><code class="json">{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjE1NjMyMDE="
    }
  }
}
</code></pre>

<p>I find it helpful to define this response as an Elm <code>String</code> type and view it in the browser. If there is an error with the query, you can see the results in the browser.</p>

<pre><code class="haskell">-- MODEL

type alias Model =
    { response : String
    }

-- UPDATE

type Msg
    = GraphQLQuery (Result Http.Error String)

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            ( { model | response = res }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | response = toString res }, Cmd.none )

initialModel : Model
initialModel =
    { response = ""
    }

init : (Model, Cmd Msg)
init =
    ( initialModel, Http.send GraphQLQuery request )

main : Program Never Model Msg
main =
    Html.program
        { init = init 
        , view = view
        , update = update
        , subscriptions = \_ -&gt; Sub.none
        }

-- VIEW

view : Model -&gt; Html Msg
view model =
    div [] [ text model.response ]
</code></pre>

<p>The code above will display a stringfied version of our query. In Part 2, we will transform the Elm <code>String</code> data object into something more useful with Elm decoders.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Union Types in Elm]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/16/understanding-union-types-in-elm/"/>
    <updated>2018-04-16T18:19:13-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/16/understanding-union-types-in-elm</id>
    <content type="html"><![CDATA[<p>Watching <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Making Impossible States Impossible</a> and reading <a href="https://becoming-functional.com/higher-level-coding-with-elm-union-types-2502d1f5a615">Higher Level Coding with Elm Union Types</a> were enlightening in my Elm development. Now, I look for places were I can refine my data model by using union types. Union types allow me to replace conditionals with pattern matching case statements. This pattern is much cleaner and easier to understand. The following is an example of how I used union types to refactor a hamburger.</p>

<h2>Elm Model</h2>

<pre><code class="haskell">-- BEFORE

type Msg
    = DisplayHamburgerItems

type alias Model = 
    { hamburger_open : Bool
    }

-- AFTER

type Msg
    = DisplayHamburgerItems Hamburger

type Hamburger
    = Open
    | Closed


type alias Model = 
    { hamburger : Hamburger
    }
</code></pre>

<h2>Elm Update</h2>

<pre><code class="haskell">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =

    -- BEFORE

    case msg of
        DisplayHamburgerItems -&gt;
            if model.hamburger_open == True then
                let
                    items = List.append model.display_hamburger ["About", "Contact", "Menu"]
                in
                    ( { model | display_hamburger = items, hamburger_open = False }, Cmd.none )
            else
                ( { model | display_hamburger = [], hamburger_open = True }, Cmd.none 


    -- AFTER

        DisplayHamburgerItems msg -&gt;
            case msg of
                Open -&gt;
                    let
                        items = List.append model.display_hamburger ["About", "Contact", "Menu"]
                    in
                        ( { model | hamburger = Open, display_hamburger = items }, Cmd.none )
                Closed -&gt;
                    ( { model | hamburger =  Closed, display_hamburger = [] }, Cmd.none )
</code></pre>

<h2>Elm View</h2>

<pre><code class="haskell">view : Model -&gt; Html Msg
view model =

    -- BEFORE

    i [ onClick (DisplayHamburgerItems) ] []

    -- AFTER

    i [ onClick (DisplayHamburgerItems (toggleHamburger model.hamburger)) ] []

viewHamburgerItems : Model -&gt; Html Msg
viewHamburgerItems model =

    -- BEFORE

    if model.hamburger_open == False then
        div [] (List.map item model.display_hamburger)
    else
        div [] []

    -- AFTER

    case model.hamburger of
        Open -&gt;
            div [] (List.map item model.display_hamburger)
        Closed -&gt;
            div [] []
</code></pre>

<p>It is easier to reason about <code>Hamburger</code> with <code>Open</code> and <code>Closed</code> types than checking against a <code>Bool</code>. Pattern matching on the union type is expressive and is really helpful when the union types grow in complexity.</p>

<p>Full code <a href="https://github.com/iacutone/menus">here</a>.</p>
]]></content>
  </entry>
  
</feed>
