<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Github | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/github/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-23T12:32:18-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 1, Communicating With GitHub]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github/"/>
    <updated>2018-04-23T10:40:40-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github</id>
    <content type="html"><![CDATA[<p>A co-worker and are using GitHub&rsquo;s GraphQL API for a side project. I am writing a series of posts around what we learned from creating the application entitled &lsquo;GraghQL and Elm&rsquo;. This post will detail how to communicate with the Github GraphQL API with Elm. All code related to these posts can be found <a href="https://github.com/iacutone/github-elm">here</a>.</p>

<p>GitHub has extensive <a href="https://developer.github.com/v4/">documentation</a> on communicating with their GraphQL server. In this post we will write a simple query and display the JSON from Github. In the next post, we will use Elm Decoders in order to turn the JSON into Elm data.</p>

<p>The <a href="https://developer.github.com/v4/explorer/">GitHub GraphQL Explorer</a> is useful for crafting queries. Let&rsquo;s write a query that fetches a user&rsquo;s id:</p>

<pre><code class="json">{
  user(login:"iacutone") {
    id
  }
}
</code></pre>

<p>With the aforementioned JSON, let&rsquo;s contruct a request to GitHub in Elm!</p>

<pre><code class="haskell">query : String
query =
    """
    query {
    {
      user(login:"iacutone") {
        id
      }
    }
    }
    """

baseUrl : String
baseUrl =
    "https://api.github.com/graphql"

bearerToken : String
bearerToken =
    "Bearer &lt;your GitHub token here&gt;"

request : Http.Request String
request =
    Http.request
    { method = "POST"
    , headers = [Http.header "Authorization" bearerToken]
    , url = baseUrl
    , body = Http.jsonBody (Encode.object [("query", Encode.string query)])
    , expect = Http.expectString
    , timeout = Nothing
    , withCredentials = False
    }
</code></pre>

<p>After posting the query to GitHub, your Elm update function will receive the following response:</p>

<pre><code class="json">{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjE1NjMyMDE="
    }
  }
}
</code></pre>

<p>I find it helpful to define this response as an Elm <code>String</code> type and view it in the browser. If there is an error with the query, you can see the results in the browser.</p>

<pre><code class="haskell">-- MODEL

type alias Model =
    { response : String
    }

-- UPDATE

type Msg
    = GraphQLQuery (Result Http.Error String)

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            ( { model | response = res }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | response = toString res }, Cmd.none )

initialModel : Model
initialModel =
    { response = ""
    }

init : (Model, Cmd Msg)
init =
    ( initialModel, Http.send GraphQLQuery request )

main : Program Never Model Msg
main =
    Html.program
        { init = init 
        , view = view
        , update = update
        , subscriptions = \_ -&gt; Sub.none
        }

-- VIEW

view : Model -&gt; Html Msg
view model =
    div [] [ text model.resposne]
</code></pre>

<p>The code above will display a stringfied version of our query. In Part 2, we will transform the Elm <code>String</code> data object into something more useful with Elm decoders.</p>
]]></content>
  </entry>
  
</feed>
