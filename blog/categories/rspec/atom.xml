<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rspec | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-23T13:03:22-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Test Doubles]]></title>
    <link href="http://iacutone.github.io/blog/2017/10/24/understanding-test-doubles/"/>
    <updated>2017-10-24T11:02:12-05:00</updated>
    <id>http://iacutone.github.io/blog/2017/10/24/understanding-test-doubles</id>
    <content type="html"><![CDATA[<p>I refactored credit card payments on an application that uses the <code>ActiveMerchant</code> gem. I was not confident in the test, so, I re-wrote the tests to verify responses from Braintree. Once I verified I did not break anything with my refactor, I decided the best next step was to remove the interaction with Braintree and replace it with stubbed responses. I always forget when and how to use RSpec <code>allow</code>, <code>spy</code> and <code>double</code> methods. This post is meant to help reinforce my knowledge of the aforementioned methods.</p>

<pre><code class="ruby">describe CreditCardPayment do
  let!(:payment) { build(:credit_card_payment) }

  describe '#authorize' do
    before { payment.authorize }

    it 'records the GatewayTransaction' do
      transaction = GatewayTransaction.last

      expect(transaction.success).to eq true
      expect(transaction.amount).to eq amount
      expect(transaction.message).to eq '1000 Approved'
      expect(transaction.response).to be_present
      expect(transaction.service_fee).to eq service_fee[:service_fee]
    end
  end
end
</code></pre>

<p>Authorize is a wrapper around the payment gateway #authorize method which returns a response from Braintree. I should have confidence that when sending Braintree arguments that the<code>#authorize</code> expects, the response will be successful. This is interaction is what needs to be stubbed in order to not call the Braintree API in the test environment. The benefits of this approach are that the test will be faster and more resilient because there is no communication with an external service. The negatives of this approach is that the API can change.</p>

<p>Let&rsquo;s update the above codeblock to stub out the interaction with Braintree.</p>

<pre><code class="ruby">describe CreditCardPayment do
  let(:gateway_double) { double('ActiveMerchant::Billing::BraintreeGateway') }
  let!(:payment) { build(:credit_card_payment, gateway: gateway_double) }

  before { payment.gateway = gateway_double }

  describe '#authorize' do
    it 'sends a #authorize request to Braintree' do
      expect(gateway_double).to receive(:authorize).exactly(1).times
        .with(amount, payment.credit_card, payment.credit_card_descriptor)
    .and_return(authorize_response_stub)

      payment.authorize
    end

    it 'creates a GatewayTransaction' do
      expect { payment.authorize }.to change(GatewayTransaction, :count).by(1)
    end
  end

  def authorize_response_stub
    params = { 'response_from_braintree' =&gt; 'yay' }

     ActiveMerchant::Billing::Response.new(true, '1000 Approved', params, {authorization: '3e4r5q'})
  end
end
</code></pre>

<p>Notice that in the <code>it</code> block the expectation comes before the <code>#payment</code> method call. We could replace the <code>double</code> with a <code>spy</code>. The difference is a spy uses the <code>have_received</code> method. It is your preference to use either a <code>double</code> or a <code>spy</code>.</p>

<pre><code class="ruby">  let(:gateway_double) { spy('ActiveMerchant::Billing::BraintreeGateway') }
  let!(:payment) { build(:credit_card_payment, gateway: gateway_double) }

  before { payment.gateway = gateway_double }

  describe '#authorize' do
    it 'sends a #authorize request to Braintree' do
      payment.authorize

      expect(gateway_double).to have_receive(:authorize).exactly(1).times
        .with(amount, payment.credit_card, payment.credit_card_descriptor)
    .and_return(authorize_response_stub)
    end

    it 'creates a GatewayTransaction' do
      expect { payment.authorize }.to change(GatewayTransaction, :count).by(1)
    end
  end
</code></pre>

<h3>Helpful Links</h3>

<p><a href="https://relishapp.com/rspec/rspec-mocks/v/3-6/docs/basics">RSpec Mocks 3.6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec and Elastic Search]]></title>
    <link href="http://iacutone.github.io/blog/2017/02/24/rspec-and-elastic-search/"/>
    <updated>2017-02-24T11:39:11-05:00</updated>
    <id>http://iacutone.github.io/blog/2017/02/24/rspec-and-elastic-search</id>
    <content type="html"><![CDATA[<p>I had a difficult time setting up  ElasticSearch on both RSpec (CircleCI) and Heroku. The ElasticSearch test cluster was not working on the CircleCI Docker image. Fortunately, one can configure the Circle environment to start with an ElasticSearch process. So, instead of using the test cluster, both my local testing environment and Circle environment use a real ElasticSearch process.</p>

<pre><code class="ruby">#
# ElasticSearch
#

config.before :all, elasticsearch: true do
  port = ENV['CIRCLE_CI_ES_URL'].present? ? 9200 : 9250
  Elasticsearch::Model.client = Elasticsearch::Client.new(port: port)
end

config.before :each, elasticsearch: true do
  Campaign.__elasticsearch__.create_index!(force: true)
end

config.after :each, elasticsearch: true do
  Campaign.__elasticsearch__.delete_index!
end
</code></pre>

<p>When a test needs to use ElasticSearch:</p>

<pre><code class="ruby">before { Campaign.__elasticsearch__.refresh_index! }

describe '#search', elasticsearch: true do
  expect(search.results).to be_present
end
</code></pre>

<p>I ran into issues using ElasticSearch on Heroku when creating an index. Heroku review apps are configurable by defining an <code>app.json</code>. In the json file, Heroku can spin up an ElasticSearch process.</p>

<pre><code>"scripts": {
  "postdeploy": "bundle exec rake db:schema:load db:seed"
},
"formation": {
  "web": {
    "size": "free",
    "quantity": 1
  },
  "elasticsearch": {
    "size": "free",
    "quantity": 1
  }
}
</code></pre>

<p>The process is running before any Ruby code is executed. The next step is to create the index using <code>postdeploy</code>. Before creating ActiveRecord objects in the <code>seed.rb</code> file, create an index with <code>Model.index(force: true)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Example Blocks]]></title>
    <link href="http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks/"/>
    <updated>2016-01-11T15:57:05-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks</id>
    <content type="html"><![CDATA[<p>I recently discovered an interesting test pattern; defining variables in before and after hooks in the rails helper.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, hook: true) do
    @hook = 'before hook'
  end
</code></pre>

<pre><code class="ruby some_spec.rb">  RSpec.describe "some variable I need" do

    describe 'my hook', hook: true do
      it 'runs the hook' do
        expect(@hook).to eq 'before hook' # returns true
      end
    end
  end
</code></pre>

<h3>A Real Example</h3>

<p>Let&rsquo;s say we are testing a controller and want to make sure only an admin has access to specific views.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, admin_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; true
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end

  config.before(:example, user_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; false
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end
</code></pre>

<p>When setting admin_signed_in to true in a describe block, we have access to an admin user. I think it is cleaner to set up these users in a hook instead of a shared context or explicitly in the spec.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/hooks/filters">Hooks</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Mocks to Test Mailers in RSpec]]></title>
    <link href="http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec/"/>
    <updated>2015-12-12T13:37:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec</id>
    <content type="html"><![CDATA[<p>I was in the situation where I needed to test the delivery of emails based on specific sets of events. I began testing by inspecting sent emails in ActionMailer::Base.deliveries. However, this method of testing felt verbose and sloppy.</p>

<p>RSpec mocks is a great solution when you need to test that a specific method was called. In my case, I want a fundraiser to receive an email after a campaign goal is reached.</p>

<pre><code class="ruby donation_funding.rb">
class DonationFunding
  attr_reader :donation

  def initialize(donation)
    @donation = donation
  end

  def fund
    # do some work
    CampaignMailer.notify_curator_campaign_goal_reached(donation)
  end
end
</code></pre>

<pre><code class="ruby donation_funding_spec.rb">
  before do
    donation.amount = campaign.goal_amount + 1
    donation.save!
  end

  # Make a donation that exceeds the funding goal

  let!(:funder) {
    funder = DonationFunding.new donation
    funder
  }

  # set up the donation for funding

  it 'sends email goal amount reached email to the curator' do
    expect(CampaignMailer).to receive(:notify_curator_campaign_goal_reached).and_call_original
    funder.fund
  end

  # Expect a CampaignMailer.notify_curator_campaign_goal_reached email to be sent
</code></pre>

<p>The definition for the method and_call_original is, &ldquo;You can use and_call_original on the fluent interface to "pass through&rdquo; the received message to the original method.&ldquo; What exactly does this mean? It means that when I call funder.fund, I expect CampaignMailer.notify_curator_campaign_goal_reached to be called.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method">Calling the original method</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared Contexts With RSpec]]></title>
    <link href="http://iacutone.github.io/blog/2015/11/20/shared-contexts-with-rspec/"/>
    <updated>2015-11-20T16:45:46-05:00</updated>
    <id>http://iacutone.github.io/blog/2015/11/20/shared-contexts-with-rspec</id>
    <content type="html"><![CDATA[<p>In the past, I used traits with my factories. Below is a simple example of defining a trait:</p>

<h3>Using traits</h3>

<pre><code class="ruby donations_factories.rb">  FactoryGirl.define do
    factory :donation do
      trait :with_amount do
        amount 10
      end

      trait :no_amount do
        amount 0
      end
    end
  end
</code></pre>

<p>An example spec:</p>

<pre><code class="ruby donation_spec.rb">  RSpec.describe 'Donation Matching', :type =&gt; :model do

    context 'with an amount' do
      let(:donation) { create(:donation, :with_amount) }
    end

    context 'with no amount' do
      let(:donation) { create(:donation, :no_amount) }
    end
  end
</code></pre>

<p>However, I believe that using a shared context is a clearer approach. Defining the amount in a shared context and overriding the amount allows more control over testing use cases.</p>

<h3>Using a shared context</h3>

<pre><code class="ruby donation_spec.rb">  require 'support/shared_contexts/donor_with_donation_context'

  RSpec.describe 'Donation Matching', :type =&gt; :model do
    include_context 'a donor with a donation'

    context 'with an amount' do
      // donation.amount == 10 (defined in the shared context)
    end

    context 'with no amount' do
      let(:amount) { 0 }
      // donation.amount == 0
    end

    context 'with a gnarly' do
      let(:amount) { 09709780 }
    end
  end
</code></pre>

<pre><code class="ruby spec/support/shared_contexts/donor_with_donation_context.rb">  RSpec.shared_context 'a donor with a donation' do
    let(:amount) { 10 }

    let(:donation) { create(:donation, amount: amount) }
  end
</code></pre>

<p>I especially like the shared context approach because you can have shared context and redefine attributes as needed in specs.</p>
]]></content>
  </entry>
  
</feed>
