<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2016-09-15T10:31:39-04:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails `before_action` Method]]></title>
    <link href="http://iacutone.github.io/blog/2016/07/13/rails-before-action-method/"/>
    <updated>2016-07-13T13:31:20-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/07/13/rails-before-action-method</id>
    <content type="html"><![CDATA[<p>I did not know you could give a <code>before_action</code> a block argument. This is a benefit because you do not have to create a ruby method and pass the method into the <code>before_action</code>.</p>

<p>This got me thinking, what does <code>before_action</code> look like in Rails? The following is the source code from Rails 4.2.7, from <code>AbstractController::Callbacks::ClassMethods</code>.</p>

<pre><code class="ruby"># :method: before_action
#
# :call-seq: before_action(names, block)
#
# Append a callback before actions. See _insert_callbacks for parameter details.

# Take callback names and an optional callback proc, normalize them,
# then call the block with each callback. This allows us to abstract
# the normalization across several methods that use it.
#
# ==== Parameters
# * &lt;tt&gt;callbacks&lt;/tt&gt; - An array of callbacks, with an optional
#   options hash as the last parameter.
# * &lt;tt&gt;block&lt;/tt&gt;    - A proc that should be added to the callbacks.
#
# ==== Block Parameters
# * &lt;tt&gt;name&lt;/tt&gt;     - The callback to be added
# * &lt;tt&gt;options&lt;/tt&gt;  - A hash of options to be used when adding the callback

def _insert_callbacks(callbacks, block = nil)
  options = callbacks.extract_options!
  _normalize_callback_options(options)
  callbacks.push(block) if block
  callbacks.each do |callback|
    yield callback, options
  end
end

[:before, :after, :around].each do |callback|
  define_method "#{callback}_action" do |*names, &amp;blk|
    _insert_callbacks(names, blk) do |name, options|
      set_callback(:process_action, callback, name, options)
    end
  end
end
</code></pre>

<p>And I can do cool things like:</p>

<pre><code class="ruby">before_action -&gt; {
  @foo = Model.find params[:bar]
}
</code></pre>

<p>I would like to point out the <code>set_callback</code> method.</p>

<pre><code class="ruby">before_action :authenticate

# can also be called like this
set_callback :process_action, :before, :authenticate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extend and Include in Ruby]]></title>
    <link href="http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby/"/>
    <updated>2016-06-02T16:25:45-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby</id>
    <content type="html"><![CDATA[<p>I have been trying to clean up some old code with Ruby modules. This post is to help me remember the differences between <code>include</code> and <code>extend</code> in Ruby.</p>

<pre><code class="ruby">class Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">module Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">Foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>

<pre><code class="ruby">class Foo
  include ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">foo = Foo.new
foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord None]]></title>
    <link href="http://iacutone.github.io/blog/2016/03/04/activerecord-none/"/>
    <updated>2016-03-04T19:15:38-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/03/04/activerecord-none</id>
    <content type="html"><![CDATA[<p>The .none class method was introduced in Rails 4.0.2 and is helpful when returning a blank array will break.</p>

<pre><code class="ruby">Organization.none.paginate(page: '1')
 =&gt; #&lt;ActiveRecord::Relation []&gt;

[].paginate(page: '1')
 =&gt; NoMethodError: undefined method `paginate' for []:Array
</code></pre>

<h3>Helpful Links</h3>

<p><a href="http://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/none">none</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Submitting a Get Request in Rails]]></title>
    <link href="http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails/"/>
    <updated>2016-02-05T15:04:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails</id>
    <content type="html"><![CDATA[<p>For the error &ldquo;WARNING: Can&rsquo;t verify CSRF token authenticity&rdquo;, add a CSRF token.</p>

<pre><code class="ruby _form.html.haml">= form_tag some_path(@organization), method: :get do
  = hidden_field_tag :authenticity_token, form_authenticity_token # this needs to be added!
  = submit_tag "View"
  = link_to_function 'Export', "Javascript function which posts to another route"
</code></pre>

<p>The top-level block contains method: :get which doesn&rsquo;t auto-add the needed authenticity_token.</p>

<h3>Helpful Links</h3>

<p><a href="http://stackoverflow.com/questions/941594/understanding-the-rails-authenticity-token">Understanding the Rails Authenticity Token</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Example Blocks]]></title>
    <link href="http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks/"/>
    <updated>2016-01-11T15:57:05-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks</id>
    <content type="html"><![CDATA[<p>I recently discovered an interesting test pattern; defining variables in before and after hooks in the rails helper.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, hook: true) do
    @hook = 'before hook'
  end
</code></pre>

<pre><code class="ruby some_spec.rb">  RSpec.describe "some variable I need" do

    describe 'my hook', hook: true do
      it 'runs the hook' do
        expect(@hook).to eq 'before hook' # returns true
      end
    end
  end
</code></pre>

<h3>A Real Example</h3>

<p>Let&rsquo;s say we are testing a controller and want to make sure only an admin has access to specific views.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, admin_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; true
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end

  config.before(:example, user_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; false
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end
</code></pre>

<p>When setting admin_signed_in to true in a describe block, we have access to an admin user. I think it is cleaner to set up these users in a hook instead of a shared context or explicitly in the spec.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/hooks/filters">Hooks</a></p>
]]></content>
  </entry>
  
</feed>
