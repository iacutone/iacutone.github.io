<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2016-03-12T15:43:09-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ActiveRecord None]]></title>
    <link href="http://iacutone.github.io/blog/2016/03/04/activerecord-none/"/>
    <updated>2016-03-04T19:15:38-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/03/04/activerecord-none</id>
    <content type="html"><![CDATA[<p>The .none class method was introduced in Rails 4.0.2 and is helpful when returning a blank array will break.</p>

<pre><code class="ruby">Organization.none.paginate(page: '1')
 =&gt; #&lt;ActiveRecord::Relation []&gt;

[].paginate(page: '1')
 =&gt; NoMethodError: undefined method `paginate' for []:Array
</code></pre>

<h3>Helpful Links</h3>

<p><a href="http://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/none">none</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Submitting a Get Request in Rails]]></title>
    <link href="http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails/"/>
    <updated>2016-02-05T15:04:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails</id>
    <content type="html"><![CDATA[<p>For the error &ldquo;WARNING: Can&rsquo;t verify CSRF token authenticity&rdquo;, add a CSRF token.</p>

<pre><code class="ruby _form.html.haml">= form_tag some_path(@organization), method: :get do
  = hidden_field_tag :authenticity_token, form_authenticity_token # this needs to be added!
  = submit_tag "View"
  = link_to_function 'Export', "Javascript function which posts to another route"
</code></pre>

<p>The top-level block contains method: :get which doesn&rsquo;t auto-add the needed authenticity_token.</p>

<h3>Helpful Links</h3>

<p><a href="http://stackoverflow.com/questions/941594/understanding-the-rails-authenticity-token">Understanding the Rails Authenticity Token</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Example Blocks]]></title>
    <link href="http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks/"/>
    <updated>2016-01-11T15:57:05-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks</id>
    <content type="html"><![CDATA[<p>I recently discovered an interesting test pattern; defining variables in before and after hooks in the rails helper.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, hook: true) do
    @hook = 'before hook'
  end
</code></pre>

<pre><code class="ruby some_spec.rb">  RSpec.describe "some variable I need" do

    describe 'my hook', hook: true do
      it 'runs the hook' do
        expect(@hook).to eq 'before hook' # returns true
      end
    end
  end
</code></pre>

<h3>A Real Example</h3>

<p>Let&rsquo;s say we are testing a controller and want to make sure only an admin has access to specific views.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, admin_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; true
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end

  config.before(:example, user_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; false
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end
</code></pre>

<p>When setting admin_signed_in to true in a describe block, we have access to an admin user. I think it is cleaner to set up these users in a hook instead of a shared context or explicitly in the spec.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/hooks/filters">Hooks</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Mocks to Test Mailers in RSpec]]></title>
    <link href="http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec/"/>
    <updated>2015-12-12T13:37:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec</id>
    <content type="html"><![CDATA[<p>I was in the situation where I needed to test the delivery of emails based on specific sets of events. I began testing by inspecting sent emails in ActionMailer::Base.deliveries. However, this method of testing felt verbose and sloppy.</p>

<p>RSpec mocks is a great solution when you need to test that a specific method was called. In my case, I want a fundraiser to receive an email after a campaign goal is reached.</p>

<pre><code class="ruby donation_funding.rb">
class DonationFunding
  attr_reader :donation

  def initialize(donation)
    @donation = donation
  end

  def fund
    # do some work
    CampaignMailer.notify_curator_campaign_goal_reached(donation)
  end
end
</code></pre>

<pre><code class="ruby donation_funding_spec.rb">
  before do
    donation.amount = campaign.goal_amount + 1
    donation.save!
  end

  # Make a donation that exceeds the funding goal

  let!(:funder) {
    funder = DonationFunding.new donation
    funder
  }

  # set up the donation for funding

  it 'sends email goal amount reached email to the curator' do
    expect(CampaignMailer).to receive(:notify_curator_campaign_goal_reached).and_call_original
    funder.fund
  end

  # Expect a CampaignMailer.notify_curator_campaign_goal_reached email to be sent
</code></pre>

<p>The definition for the method and_call_original is, &ldquo;You can use and_call_original on the fluent interface to "pass through&rdquo; the received message to the original method.&ldquo; What exactly does this mean? It means that when I call funder.fund, I expect CampaignMailer.notify_curator_campaign_goal_reached to be called.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method">Calling the original method</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared Contexts With RSpec]]></title>
    <link href="http://iacutone.github.io/blog/2015/11/20/shared-contexts-with-rspec/"/>
    <updated>2015-11-20T16:45:46-05:00</updated>
    <id>http://iacutone.github.io/blog/2015/11/20/shared-contexts-with-rspec</id>
    <content type="html"><![CDATA[<p>In the past, I used traits with my factories. Below is a simple example of defining a trait:</p>

<h3>Using traits</h3>

<pre><code class="ruby donations_factories.rb">  FactoryGirl.define do
    factory :donation do
      trait :with_amount do
        amount 10
      end

      trait :no_amount do
        amount 0
      end
    end
  end
</code></pre>

<p>An example spec:</p>

<pre><code class="ruby donation_spec.rb">  RSpec.describe 'Donation Matching', :type =&gt; :model do

    context 'with an amount' do
      let(:donation) { create(:donation, :with_amount) }
    end

    context 'with no amount' do
      let(:donation) { create(:donation, :no_amount) }
    end
  end
</code></pre>

<p>However, I believe that using a shared context is a clearer approach. Defining the amount in a shared context and overriding the amount allows more control over testing use cases.</p>

<h3>Using a shared context</h3>

<pre><code class="ruby donation_spec.rb">  require 'support/shared_contexts/donor_with_donation_context'

  RSpec.describe 'Donation Matching', :type =&gt; :model do
    include_context 'a donor with a donation'

    context 'with an amount' do
      // donation.amount == 10 (defined in the shared context)
    end

    context 'with no amount' do
      let(:amount) { 0 }
      // donation.amount == 0
    end

    context 'with a gnarly' do
      let(:amount) { 09709780 }
    end
  end
</code></pre>

<pre><code class="ruby spec/support/shared_contexts/donor_with_donation_context.rb">  RSpec.shared_context 'a donor with a donation' do
    let(:amount) { 10 }

    let(:donation) { create(:donation, amount: amount) }
  end
</code></pre>

<p>I especially like the shared context approach because you can have shared context and redefine attributes as needed in specs.</p>
]]></content>
  </entry>
  
</feed>
