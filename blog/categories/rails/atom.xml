<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2017-04-29T11:24:49-04:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RSpec and Elastic Search]]></title>
    <link href="http://iacutone.github.io/blog/2017/02/24/rspec-and-elastic-search/"/>
    <updated>2017-02-24T11:39:11-05:00</updated>
    <id>http://iacutone.github.io/blog/2017/02/24/rspec-and-elastic-search</id>
    <content type="html"><![CDATA[<p>I had a difficult time setting up  ElasticSearch on both RSpec (CircleCI) and Heroku. The ElasticSearch test cluster was not working on the CircleCI Docker image. Fortunately, one can configure the Circle environment to start with an ElasticSearch process. So, instead of using the test cluster, both my local testing environment and Circle environment use a real ElasticSearch process.</p>

<pre><code class="ruby">#
# ElasticSearch
#

config.before :all, elasticsearch: true do
  port = ENV['CIRCLE_CI_ES_URL'].present? ? 9200 : 9250
  Elasticsearch::Model.client = Elasticsearch::Client.new(port: port)
end

config.before :each, elasticsearch: true do
  Campaign.__elasticsearch__.create_index!(force: true)
end

config.after :each, elasticsearch: true do
  Campaign.__elasticsearch__.delete_index!
end
</code></pre>

<p>When a test needs to use ElasticSearch:</p>

<pre><code class="ruby">before { Campaign.__elasticsearch__.refresh_index! }

describe '#search', elasticsearch: true do
  expect(search.results).to be_present
end
</code></pre>

<p>I ran into issues using ElasticSearch on Heroku when creating an index. Heroku review apps are configurable by defining an <code>app.json</code>. In the json file, Heroku can spin up an ElasticSearch process.</p>

<pre><code>"scripts": {
  "postdeploy": "bundle exec rake db:schema:load db:seed"
},
"formation": {
  "web": {
    "size": "free",
    "quantity": 1
  },
  "elasticsearch": {
    "size": "free",
    "quantity": 1
  }
}
</code></pre>

<p>The process is running before any Ruby code is executed. The next step is to create the index using <code>postdeploy</code>. Before creating ActiveRecord objects in the <code>seed.rb</code> file, create an index with <code>Model.index(force: true)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails `before_action` Method]]></title>
    <link href="http://iacutone.github.io/blog/2016/07/13/rails-before-action-method/"/>
    <updated>2016-07-13T13:31:20-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/07/13/rails-before-action-method</id>
    <content type="html"><![CDATA[<p>I did not know you could give a <code>before_action</code> a block argument. This is a benefit because you do not have to create a ruby method and pass the method into the <code>before_action</code>.</p>

<p>This got me thinking, what does <code>before_action</code> look like in Rails? The following is the source code from Rails 4.2.7, from <code>AbstractController::Callbacks::ClassMethods</code>.</p>

<pre><code class="ruby"># :method: before_action
#
# :call-seq: before_action(names, block)
#
# Append a callback before actions. See _insert_callbacks for parameter details.

# Take callback names and an optional callback proc, normalize them,
# then call the block with each callback. This allows us to abstract
# the normalization across several methods that use it.
#
# ==== Parameters
# * &lt;tt&gt;callbacks&lt;/tt&gt; - An array of callbacks, with an optional
#   options hash as the last parameter.
# * &lt;tt&gt;block&lt;/tt&gt;    - A proc that should be added to the callbacks.
#
# ==== Block Parameters
# * &lt;tt&gt;name&lt;/tt&gt;     - The callback to be added
# * &lt;tt&gt;options&lt;/tt&gt;  - A hash of options to be used when adding the callback

def _insert_callbacks(callbacks, block = nil)
  options = callbacks.extract_options!
  _normalize_callback_options(options)
  callbacks.push(block) if block
  callbacks.each do |callback|
    yield callback, options
  end
end

[:before, :after, :around].each do |callback|
  define_method "#{callback}_action" do |*names, &amp;blk|
    _insert_callbacks(names, blk) do |name, options|
      set_callback(:process_action, callback, name, options)
    end
  end
end
</code></pre>

<p>And I can do cool things like:</p>

<pre><code class="ruby">before_action -&gt; {
  @foo = Model.find params[:bar]
}
</code></pre>

<p>I would like to point out the <code>set_callback</code> method.</p>

<pre><code class="ruby">before_action :authenticate

# can also be called like this
set_callback :process_action, :before, :authenticate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extend and Include in Ruby]]></title>
    <link href="http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby/"/>
    <updated>2016-06-02T16:25:45-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby</id>
    <content type="html"><![CDATA[<p>I have been trying to clean up some old code with Ruby modules. This post is to help me remember the differences between <code>include</code> and <code>extend</code> in Ruby.</p>

<pre><code class="ruby">class Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">module Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">Foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>

<pre><code class="ruby">class Foo
  include ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">foo = Foo.new
foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord None]]></title>
    <link href="http://iacutone.github.io/blog/2016/03/04/activerecord-none/"/>
    <updated>2016-03-04T19:15:38-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/03/04/activerecord-none</id>
    <content type="html"><![CDATA[<p>The .none class method was introduced in Rails 4.0.2 and is helpful when returning a blank array will break.</p>

<pre><code class="ruby">Organization.none.paginate(page: '1')
 =&gt; #&lt;ActiveRecord::Relation []&gt;

[].paginate(page: '1')
 =&gt; NoMethodError: undefined method `paginate' for []:Array
</code></pre>

<h3>Helpful Links</h3>

<p><a href="http://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/none">none</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Submitting a Get Request in Rails]]></title>
    <link href="http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails/"/>
    <updated>2016-02-05T15:04:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/02/05/submitting-a-get-request-in-rails</id>
    <content type="html"><![CDATA[<p>For the error &ldquo;WARNING: Can&rsquo;t verify CSRF token authenticity&rdquo;, add a CSRF token.</p>

<pre><code class="ruby _form.html.haml">= form_tag some_path(@organization), method: :get do
  = hidden_field_tag :authenticity_token, form_authenticity_token # this needs to be added!
  = submit_tag "View"
  = link_to_function 'Export', "Javascript function which posts to another route"
</code></pre>

<p>The top-level block contains method: :get which doesn&rsquo;t auto-add the needed authenticity_token.</p>

<h3>Helpful Links</h3>

<p><a href="http://stackoverflow.com/questions/941594/understanding-the-rails-authenticity-token">Understanding the Rails Authenticity Token</a></p>
]]></content>
  </entry>
  
</feed>
