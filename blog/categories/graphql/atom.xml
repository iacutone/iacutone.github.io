<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Graphql | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-26T17:02:30-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 2, Parsing Nested JSON]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/25/graphql-with-elm-part-2/"/>
    <updated>2018-04-25T14:17:04-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/25/graphql-with-elm-part-2</id>
    <content type="html"><![CDATA[<p>In this post we will discuss how to turn nested JSON into Elm data types. This post uses a thin <code>Elm.Http</code> <a href="https://github.com/NoRedInk/elm-decode-pipeline">wrapper</a>. Using this library helps us concentrate on contructing the necessary Decoders. We will also contruct a more complex query in order to explain how to contruct complex data types. The following query returns JSON for the first two team members of FracturedAtlas.</p>

<pre><code class="haskell">query : String
query =
    """
    query {
      organization(login: "FracturedAtlas") {
        team(slug: "fa-dev") {
          members(first:2) {
            edges {
              node {
                id
                login
              }
            }
          }
        }
      }
    }
    """
</code></pre>

<p>Swapping out our query will return the following JSON.</p>

<pre><code class="json">{"data":{"organization":{"team":{"members":{"edges":[{"node":{"id":"&lt;user id&gt;","login":"&lt;user name&gt;"}},{"node":{"id":"&lt;another user id&gt;","login":"&lt;user name&gt;"}}]}}}}}
</code></pre>

<p>The following part took me a long time to grok. The issues I had difficulty resolving are:
1. How do I grab the list of nodes?
1. How to I change my stringified JSON output into Elm data types?</p>

<p>The rest of this post tackles these two issues.</p>

<p>The <code>requiredAt</code> function from Elm Decode Pipeline solves the first problem.</p>

<pre><code class="haskell">decodeLogin =
    decode Users
            |&gt; requiredAt ["data", "organization", "team", "members", "edges"] (Json.Decode.list decodeNode)
        -- 'dig' into the JSON and extract the node list

decodeNode =
    decode Node
        |&gt; required "node" decodeUser

decodeUser =
    decode User
        |&gt; required "id" string
        |&gt; required "login" string
</code></pre>

<p>Let&rsquo;s construct our Elm datatypes based on the JSON response.</p>

<pre><code class="haskell">type alias Model =
    { message : String
    , users : Maybe Users
    }

type alias Users =
    { edges : List Node }

type alias Node =
    { node: User
    }

type alias User =
    { id:  String
    , login : String
    }
</code></pre>

<p>Now to handle the update function.</p>

<pre><code class="haskell">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            case decodeString decodeLogin res of
                Ok res -&gt;
                    ( { model | users = Just res }, Cmd.none )
                Err error -&gt;
                    ( { model | message = error, users = Nothing }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | users = Nothing }, Cmd.none )
</code></pre>

<p>I spent numerous hours figuring out how to map the Elm data types to the decoders. In Part 3, we will learn how to display the <code>User</code> data type in the browser.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL With Elm Part 1, Communicating With GitHub]]></title>
    <link href="http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github/"/>
    <updated>2018-04-23T10:40:40-05:00</updated>
    <id>http://iacutone.github.io/blog/2018/04/23/graphql-with-elm-part-1-communicating-with-github</id>
    <content type="html"><![CDATA[<p>A co-worker and are using GitHub&rsquo;s GraphQL API for a side project. I am writing a series of posts around what we learned from creating the application entitled &lsquo;GraghQL and Elm&rsquo;. This post will detail how to communicate with the Github GraphQL API with Elm. All code related to these posts can be found <a href="https://github.com/iacutone/github-elm">here</a>.</p>

<p>GitHub has extensive <a href="https://developer.github.com/v4/">documentation</a> on communicating with their GraphQL server. In this post we will write a simple query and display the JSON from Github. In the next post, we will use Elm Decoders in order to turn the JSON into Elm data.</p>

<p>The <a href="https://developer.github.com/v4/explorer/">GitHub GraphQL Explorer</a> is useful for crafting queries. Let&rsquo;s write a query that fetches a user&rsquo;s id:</p>

<pre><code class="json">{
  user(login:"iacutone") {
    id
  }
}
</code></pre>

<p>With the aforementioned JSON, let&rsquo;s contruct a request to GitHub in Elm!</p>

<pre><code class="haskell">query : String
query =
    """
    query {
      {
        user(login:"iacutone") {
          id
        }
      }
    }
"""

baseUrl : String
baseUrl =
    "https://api.github.com/graphql"

bearerToken : String
bearerToken =
    "Bearer &lt;your GitHub token here&gt;"

request : Http.Request String
request =
    Http.request
    { method = "POST"
    , headers = [Http.header "Authorization" bearerToken]
    , url = baseUrl
    , body = Http.jsonBody (Encode.object [("query", Encode.string query)])
    , expect = Http.expectString
    , timeout = Nothing
    , withCredentials = False
    }
</code></pre>

<p>After posting the query to GitHub, your Elm update function will receive the following response:</p>

<pre><code class="json">{
  "data": {
    "user": {
      "id": "MDQ6VXNlcjE1NjMyMDE="
    }
  }
}
</code></pre>

<p>I find it helpful to define this response as an Elm <code>String</code> type and view it in the browser. If there is an error with the query, you can see the results in the browser.</p>

<pre><code class="haskell">-- MODEL

type alias Model =
    { response : String
    }

-- UPDATE

type Msg
    = GraphQLQuery (Result Http.Error String)

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GraphQLQuery (Ok res) -&gt;
            ( { model | response = res }, Cmd.none )

        GraphQLQuery (Err res) -&gt;
            ( { model | response = toString res }, Cmd.none )

initialModel : Model
initialModel =
    { response = ""
    }

init : (Model, Cmd Msg)
init =
    ( initialModel, Http.send GraphQLQuery request )

main : Program Never Model Msg
main =
    Html.program
        { init = init 
        , view = view
        , update = update
        , subscriptions = \_ -&gt; Sub.none
        }

-- VIEW

view : Model -&gt; Html Msg
view model =
    div [] [ text model.response ]
</code></pre>

<p>The code above will display a stringfied version of our query. In Part 2, we will transform the Elm <code>String</code> data object into something more useful with Elm decoders.</p>
]]></content>
  </entry>
  
</feed>
