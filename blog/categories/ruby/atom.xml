<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2016-11-01T17:37:39-04:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails `before_action` Method]]></title>
    <link href="http://iacutone.github.io/blog/2016/07/13/rails-before-action-method/"/>
    <updated>2016-07-13T13:31:20-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/07/13/rails-before-action-method</id>
    <content type="html"><![CDATA[<p>I did not know you could give a <code>before_action</code> a block argument. This is a benefit because you do not have to create a ruby method and pass the method into the <code>before_action</code>.</p>

<p>This got me thinking, what does <code>before_action</code> look like in Rails? The following is the source code from Rails 4.2.7, from <code>AbstractController::Callbacks::ClassMethods</code>.</p>

<pre><code class="ruby"># :method: before_action
#
# :call-seq: before_action(names, block)
#
# Append a callback before actions. See _insert_callbacks for parameter details.

# Take callback names and an optional callback proc, normalize them,
# then call the block with each callback. This allows us to abstract
# the normalization across several methods that use it.
#
# ==== Parameters
# * &lt;tt&gt;callbacks&lt;/tt&gt; - An array of callbacks, with an optional
#   options hash as the last parameter.
# * &lt;tt&gt;block&lt;/tt&gt;    - A proc that should be added to the callbacks.
#
# ==== Block Parameters
# * &lt;tt&gt;name&lt;/tt&gt;     - The callback to be added
# * &lt;tt&gt;options&lt;/tt&gt;  - A hash of options to be used when adding the callback

def _insert_callbacks(callbacks, block = nil)
  options = callbacks.extract_options!
  _normalize_callback_options(options)
  callbacks.push(block) if block
  callbacks.each do |callback|
    yield callback, options
  end
end

[:before, :after, :around].each do |callback|
  define_method "#{callback}_action" do |*names, &amp;blk|
    _insert_callbacks(names, blk) do |name, options|
      set_callback(:process_action, callback, name, options)
    end
  end
end
</code></pre>

<p>And I can do cool things like:</p>

<pre><code class="ruby">before_action -&gt; {
  @foo = Model.find params[:bar]
}
</code></pre>

<p>I would like to point out the <code>set_callback</code> method.</p>

<pre><code class="ruby">before_action :authenticate

# can also be called like this
set_callback :process_action, :before, :authenticate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extend and Include in Ruby]]></title>
    <link href="http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby/"/>
    <updated>2016-06-02T16:25:45-04:00</updated>
    <id>http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby</id>
    <content type="html"><![CDATA[<p>I have been trying to clean up some old code with Ruby modules. This post is to help me remember the differences between <code>include</code> and <code>extend</code> in Ruby.</p>

<pre><code class="ruby">class Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">module Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">Foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>

<pre><code class="ruby">class Foo
  include ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">foo = Foo.new
foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord None]]></title>
    <link href="http://iacutone.github.io/blog/2016/03/04/activerecord-none/"/>
    <updated>2016-03-04T19:15:38-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/03/04/activerecord-none</id>
    <content type="html"><![CDATA[<p>The .none class method was introduced in Rails 4.0.2 and is helpful when returning a blank array will break.</p>

<pre><code class="ruby">Organization.none.paginate(page: '1')
 =&gt; #&lt;ActiveRecord::Relation []&gt;

[].paginate(page: '1')
 =&gt; NoMethodError: undefined method `paginate' for []:Array
</code></pre>

<h3>Helpful Links</h3>

<p><a href="http://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/none">none</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Example Blocks]]></title>
    <link href="http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks/"/>
    <updated>2016-01-11T15:57:05-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks</id>
    <content type="html"><![CDATA[<p>I recently discovered an interesting test pattern; defining variables in before and after hooks in the rails helper.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, hook: true) do
    @hook = 'before hook'
  end
</code></pre>

<pre><code class="ruby some_spec.rb">  RSpec.describe "some variable I need" do

    describe 'my hook', hook: true do
      it 'runs the hook' do
        expect(@hook).to eq 'before hook' # returns true
      end
    end
  end
</code></pre>

<h3>A Real Example</h3>

<p>Let&rsquo;s say we are testing a controller and want to make sure only an admin has access to specific views.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, admin_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; true
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end

  config.before(:example, user_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; false
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end
</code></pre>

<p>When setting admin_signed_in to true in a describe block, we have access to an admin user. I think it is cleaner to set up these users in a hook instead of a shared context or explicitly in the spec.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/hooks/filters">Hooks</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Mocks to Test Mailers in RSpec]]></title>
    <link href="http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec/"/>
    <updated>2015-12-12T13:37:18-05:00</updated>
    <id>http://iacutone.github.io/blog/2015/12/12/using-mocks-to-test-mailers-in-rspec</id>
    <content type="html"><![CDATA[<p>I was in the situation where I needed to test the delivery of emails based on specific sets of events. I began testing by inspecting sent emails in ActionMailer::Base.deliveries. However, this method of testing felt verbose and sloppy.</p>

<p>RSpec mocks is a great solution when you need to test that a specific method was called. In my case, I want a fundraiser to receive an email after a campaign goal is reached.</p>

<pre><code class="ruby donation_funding.rb">
class DonationFunding
  attr_reader :donation

  def initialize(donation)
    @donation = donation
  end

  def fund
    # do some work
    CampaignMailer.notify_curator_campaign_goal_reached(donation)
  end
end
</code></pre>

<pre><code class="ruby donation_funding_spec.rb">
  before do
    donation.amount = campaign.goal_amount + 1
    donation.save!
  end

  # Make a donation that exceeds the funding goal

  let!(:funder) {
    funder = DonationFunding.new donation
    funder
  }

  # set up the donation for funding

  it 'sends email goal amount reached email to the curator' do
    expect(CampaignMailer).to receive(:notify_curator_campaign_goal_reached).and_call_original
    funder.fund
  end

  # Expect a CampaignMailer.notify_curator_campaign_goal_reached email to be sent
</code></pre>

<p>The definition for the method and_call_original is, &ldquo;You can use and_call_original on the fluent interface to "pass through&rdquo; the received message to the original method.&ldquo; What exactly does this mean? It means that when I call funder.fund, I expect CampaignMailer.notify_curator_campaign_goal_reached to be called.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method">Calling the original method</a></p>
]]></content>
  </entry>
  
</feed>
