<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Iacutone.rb]]></title>
  <link href="http://iacutone.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://iacutone.github.io/"/>
  <updated>2018-04-26T17:05:37-05:00</updated>
  <id>http://iacutone.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Test Doubles]]></title>
    <link href="http://iacutone.github.io/blog/2017/10/24/understanding-test-doubles/"/>
    <updated>2017-10-24T11:02:12-05:00</updated>
    <id>http://iacutone.github.io/blog/2017/10/24/understanding-test-doubles</id>
    <content type="html"><![CDATA[<p>I refactored credit card payments on an application that uses the <code>ActiveMerchant</code> gem. I was not confident in the test, so, I re-wrote the tests to verify responses from Braintree. Once I verified I did not break anything with my refactor, I decided the best next step was to remove the interaction with Braintree and replace it with stubbed responses. I always forget when and how to use RSpec <code>allow</code>, <code>spy</code> and <code>double</code> methods. This post is meant to help reinforce my knowledge of the aforementioned methods.</p>

<pre><code class="ruby">describe CreditCardPayment do
  let!(:payment) { build(:credit_card_payment) }

  describe '#authorize' do
    before { payment.authorize }

    it 'records the GatewayTransaction' do
      transaction = GatewayTransaction.last

      expect(transaction.success).to eq true
      expect(transaction.amount).to eq amount
      expect(transaction.message).to eq '1000 Approved'
      expect(transaction.response).to be_present
      expect(transaction.service_fee).to eq service_fee[:service_fee]
    end
  end
end
</code></pre>

<p>Authorize is a wrapper around the payment gateway #authorize method which returns a response from Braintree. I should have confidence that when sending Braintree arguments that the<code>#authorize</code> expects, the response will be successful. This is interaction is what needs to be stubbed in order to not call the Braintree API in the test environment. The benefits of this approach are that the test will be faster and more resilient because there is no communication with an external service. The negatives of this approach is that the API can change.</p>

<p>Let&rsquo;s update the above codeblock to stub out the interaction with Braintree.</p>

<pre><code class="ruby">describe CreditCardPayment do
  let(:gateway_double) { double('ActiveMerchant::Billing::BraintreeGateway') }
  let!(:payment) { build(:credit_card_payment, gateway: gateway_double) }

  before { payment.gateway = gateway_double }

  describe '#authorize' do
    it 'sends a #authorize request to Braintree' do
      expect(gateway_double).to receive(:authorize).exactly(1).times
        .with(amount, payment.credit_card, payment.credit_card_descriptor)
    .and_return(authorize_response_stub)

      payment.authorize
    end

    it 'creates a GatewayTransaction' do
      expect { payment.authorize }.to change(GatewayTransaction, :count).by(1)
    end
  end

  def authorize_response_stub
    params = { 'response_from_braintree' =&gt; 'yay' }

     ActiveMerchant::Billing::Response.new(true, '1000 Approved', params, {authorization: '3e4r5q'})
  end
end
</code></pre>

<p>Notice that in the <code>it</code> block the expectation comes before the <code>#payment</code> method call. We could replace the <code>double</code> with a <code>spy</code>. The difference is a spy uses the <code>have_received</code> method. It is your preference to use either a <code>double</code> or a <code>spy</code>.</p>

<pre><code class="ruby">  let(:gateway_double) { spy('ActiveMerchant::Billing::BraintreeGateway') }
  let!(:payment) { build(:credit_card_payment, gateway: gateway_double) }

  before { payment.gateway = gateway_double }

  describe '#authorize' do
    it 'sends a #authorize request to Braintree' do
      payment.authorize

      expect(gateway_double).to have_receive(:authorize).exactly(1).times
        .with(amount, payment.credit_card, payment.credit_card_descriptor)
    .and_return(authorize_response_stub)
    end

    it 'creates a GatewayTransaction' do
      expect { payment.authorize }.to change(GatewayTransaction, :count).by(1)
    end
  end
</code></pre>

<h3>Helpful Links</h3>

<p><a href="https://relishapp.com/rspec/rspec-mocks/v/3-6/docs/basics">RSpec Mocks 3.6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails `before_action` Method]]></title>
    <link href="http://iacutone.github.io/blog/2016/07/13/rails-before-action-method/"/>
    <updated>2016-07-13T12:31:20-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/07/13/rails-before-action-method</id>
    <content type="html"><![CDATA[<p>I did not know you could give a <code>before_action</code> a block argument. This is a benefit because you do not have to create a ruby method and pass the method into the <code>before_action</code>.</p>

<p>This got me thinking, what does <code>before_action</code> look like in Rails? The following is the source code from Rails 4.2.7, from <code>AbstractController::Callbacks::ClassMethods</code>.</p>

<pre><code class="ruby"># :method: before_action
#
# :call-seq: before_action(names, block)
#
# Append a callback before actions. See _insert_callbacks for parameter details.

# Take callback names and an optional callback proc, normalize them,
# then call the block with each callback. This allows us to abstract
# the normalization across several methods that use it.
#
# ==== Parameters
# * &lt;tt&gt;callbacks&lt;/tt&gt; - An array of callbacks, with an optional
#   options hash as the last parameter.
# * &lt;tt&gt;block&lt;/tt&gt;    - A proc that should be added to the callbacks.
#
# ==== Block Parameters
# * &lt;tt&gt;name&lt;/tt&gt;     - The callback to be added
# * &lt;tt&gt;options&lt;/tt&gt;  - A hash of options to be used when adding the callback

def _insert_callbacks(callbacks, block = nil)
  options = callbacks.extract_options!
  _normalize_callback_options(options)
  callbacks.push(block) if block
  callbacks.each do |callback|
    yield callback, options
  end
end

[:before, :after, :around].each do |callback|
  define_method "#{callback}_action" do |*names, &amp;blk|
    _insert_callbacks(names, blk) do |name, options|
      set_callback(:process_action, callback, name, options)
    end
  end
end
</code></pre>

<p>And I can do cool things like:</p>

<pre><code class="ruby">before_action -&gt; {
  @foo = Model.find params[:bar]
}
</code></pre>

<p>I would like to point out the <code>set_callback</code> method.</p>

<pre><code class="ruby">before_action :authenticate

# can also be called like this
set_callback :process_action, :before, :authenticate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extend and Include in Ruby]]></title>
    <link href="http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby/"/>
    <updated>2016-06-02T15:25:45-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/06/02/extend-and-include-in-ruby</id>
    <content type="html"><![CDATA[<p>I have been trying to clean up some old code with Ruby modules. This post is to help me remember the differences between <code>include</code> and <code>extend</code> in Ruby.</p>

<pre><code class="ruby">class Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">module Foo
  extend ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">Foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>

<pre><code class="ruby">class Foo
  include ActionView::Helpers::NumberHelper
end
</code></pre>

<pre><code class="ruby">foo = Foo.new
foo.number_to_currency 2
 =&gt; "$2.00"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord None]]></title>
    <link href="http://iacutone.github.io/blog/2016/03/04/activerecord-none/"/>
    <updated>2016-03-04T19:15:38-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/03/04/activerecord-none</id>
    <content type="html"><![CDATA[<p>The .none class method was introduced in Rails 4.0.2 and is helpful when returning a blank array will break.</p>

<pre><code class="ruby">Organization.none.paginate(page: '1')
 =&gt; #&lt;ActiveRecord::Relation []&gt;

[].paginate(page: '1')
 =&gt; NoMethodError: undefined method `paginate' for []:Array
</code></pre>

<h3>Helpful Links</h3>

<p><a href="http://apidock.com/rails/v4.0.2/ActiveRecord/QueryMethods/none">none</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Example Blocks]]></title>
    <link href="http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks/"/>
    <updated>2016-01-11T15:57:05-05:00</updated>
    <id>http://iacutone.github.io/blog/2016/01/11/rspec-example-blocks</id>
    <content type="html"><![CDATA[<p>I recently discovered an interesting test pattern; defining variables in before and after hooks in the rails helper.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, hook: true) do
    @hook = 'before hook'
  end
</code></pre>

<pre><code class="ruby some_spec.rb">  RSpec.describe "some variable I need" do

    describe 'my hook', hook: true do
      it 'runs the hook' do
        expect(@hook).to eq 'before hook' # returns true
      end
    end
  end
</code></pre>

<h3>A Real Example</h3>

<p>Let&rsquo;s say we are testing a controller and want to make sure only an admin has access to specific views.</p>

<pre><code class="ruby rails_helper.rb">  config.before(:example, admin_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; true
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end

  config.before(:example, user_signed_in: true) do
    current_user_double = Test::User.new :admin =&gt; false
    allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(current_user_double)
  end
</code></pre>

<p>When setting admin_signed_in to true in a describe block, we have access to an admin user. I think it is cleaner to set up these users in a hook instead of a shared context or explicitly in the spec.</p>

<p>Helpful Links</p>

<p><a href="https://www.relishapp.com/rspec/rspec-core/docs/hooks/filters">Hooks</a></p>
]]></content>
  </entry>
  
</feed>
